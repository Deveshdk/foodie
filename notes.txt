Why don't we use normal JS variable instead of state variable?
    -   In state variable, whenever the state of any variable is changed, react re-renders the whole component with the updated value(
        which is found by diff algorithm/also know as reconciliation) and only updates the modified value.
    -   But in normal JS variable, even if the value of the variabe is changed, it will not render in the UI as react does not know 
        if there is any change. eg. Login button
    


Optional Chaining :
    -   ?.: This is the optional chaining operator. 
        It checks if the property preceding it (address, contact) exists and is not null or undefined
        before attempting to access the subsequent property (street, email).
    -   If the property or method before the ?. is null or undefined, the expression will short-circuit 
        and return undefined immediately without throwing an error. 
    -   This helps prevent the "Cannot read property 'x' of undefined" error.
    
    -   eg. resData?.info.areaName.
    -   We are using optional chaining and write like this 
        const {cloudinaryImageId, name, cuisines, avgRating, areaName} = resData?.info; 
        to reduce the messed code and minimize the repetition of code as well.
        Now we can directly use the values with just name below.
        


    <RestaurantCard resData = {restCardsList[0]}/>  {/* passing props to the component */}
    <RestaurantCard resData = {restCardsList[1]}/> 
    <RestaurantCard resData = {restCardsList[2]}/> 
    <RestaurantCard resData = {restCardsList[3]}/> 
    This is not a good practice to create component one by one and map the restraurants with its index value.
    Instead we wil create components based on list count and map dynamically by using list.map(component) javascript function below.
    Always provide a key when looping through a lit.
    -   eg. {topRatedRestaurantList.map(restaurant=>(<RestaurantCard key={restaurant.info.id} resData={restaurant}/>))}; 

    not using keys (not acceptable) <<< usning index as key <<< unique id as key (best practice)



    We can't use multiple default exports, instead we use named exports.
    eg. export const CDN_URL = "https://media-assets.swiggy.com/swiggy/image/upload/fl_lossy,f_auto,q_auto,w_660/";

    But we import named exports  with curly brackets{}.
    eg. import { CDN_URL } from "../utils/constants";


React Hooks:

    React Hooks are functions that allow functional components in React to use state, lifecycle methods, context,
    and other React features without writing a class.
    They were introduced in React version 16.8 to address various challenges
    and provide a cleaner way to manage stateful logic in functional components.

    useState():
        -   Used for state manangement, manages component level states.
        -   In order to use useState(), we have to import it from react first as named imoort inside curly brackets. 
        -   eg. import { useState } from "react";
        -   It is a super powerful state variable.
        -   It takes some default value.
        -   eg. const [topRatedRestaurantList,setTopRatedRestaurantList] = useState([restCardsList]);     
            here restCardsList is a default value for topRatedRestaurantList.
        -   It takes an additional set function for the state manipulation. eg. setTopRatedRestaurantList
        -   how to set the listValue.
            eg. 
                <button className="filter-btn" onClick={()=>{
                    const filteredList=restCardsList.filter(res => res.info.avgRating>4);
                    setTopRatedRestaurantList(filteredList);
                }}>4+ Rated Restaurants</button>
        -   Whenever a state variable updates, react re-renders the component.
        -    state variable is meant ot be created inside a functional component at the higher level.
            eg. never create a state variable outside of the functional component.
                never create a state variable inside a conditional statement. i.e. if else.
                never create a state variable inside a loop.
                never create a state variable inside a function even though it will not give error. It's not a good practice.


    useEffect():
        -   manages the lifecycle of the component. replaces componentDidMount,componenDidUpdate,componentWillMount.
        -   useEffect is a normal JS function.
        -   It is called after the component has been rendered.
        -   It is very useful for better UX.
        -   It can be imported in the same way as useState like named import from react. eg. import {useEffect} from "react";
        -   eg.     useEffect(() => {
                    fetchData();
                    },[]);
        -   dependency array is not necessary in useEffect.
        -   case 1: if no dependency array, useEffect will be called on every component render.
        -   case 2: if empty dependency array, useEffect will one be called once i.e initially on the page load.
        -   case 3: if dependency array is not empty, useEffect will be called every time there is a change in the dependency array state.
    
    useContext(): 
        -   Allows functional components to consume data from React Context API.
            It provides access to the value of the nearest Context provider.

    useReducer(): 
        -   Alternative to useState for managing more complex state logic.
            It uses a reducer function and returns the current state and a dispatch function.

    useCallback():
        -   Memoizes functions to prevent unnecessary re-renders of components that rely on these functions.

    useMemo():
        -   Memoizes the result of a function to improve performance by caching expensive computations.

    useRef():
        -   Returns a mutable ref object that persists across renders and can hold a reference to a DOM element or any mutable value.

    useImperativeHandle():
        -   Customizes the instance value that is exposed when using ref with forwardRef.

    useLayoutEffect():
        -   Similar to useEffect, but it runs synchronously after all DOM mutations.
            It's often used for code that needs to run after the DOM is updated.

    useDebugValue():
        -   Helps display a label for custom hooks in React DevTools.
    
    useRouteError():
        -   It can be imported as named import from react-router-dom. eg. import {useRouteErro} from "react-router-dom";
        -   It is developer friendly and can be used to show error in the UI.
            eg. const Error = () =>{
                const err = useRouteError();
                return (
                <div className="error">
                <h1>{err.status} {err.statusText}</h1>
                <h2>{err.data}</h2>
                </div>
                );
            }   

Custom Hooks :


Reconciliation Algorithm (React Fiber) : 
    -   Whenever something changes in the UI or in state variable, it is called reconciliation.
    -   It is the new way of finding the diff and updating the DOM.


Virtual Dom : 
    -   Virtual DOM is a representation of an Actual DOM or / a javascript object or / nested div tags.
        eg. <Body /> component => 
        <div className="body">
            <div className="filter">
                <button className="filter-btn" onClick={()=>{
                    const filteredList=restCardsList.filter(res => res.info.avgRating>4);
                    setTopRatedRestaurantList(filteredList);
                }}>4+ Rated Restaurants</button>
            </div>
            <div className="search">Search</div>
            <div className="res-container">
                {topRatedRestaurantList.map(restaurant=>(<RestaurantCard key={restaurant.info.id} resData={restaurant}/>))};   {/**This is a config driven UI as the card is now dependent on data. */}
            </div>
        </div>
            

Diff Algorithm :
    -   It finds the difference between two virtual DOM and then updates the actual DOM. i.e. react becomes faster.
    -   Virtual DOM is nothing but a javascript object.
        eg. Earlier there were 21 restaurants in our Virtual DOM, after filter 15 restaurants in Virtual DOM.
            So, diff algorith will find the difference between both the Virtual DOM/ object and then update the actual DOM.


Monolith Architecture vs Microservice Architecture:
    
    Microservice Architecture :
        Decomposed Services:
            Applications are divided into smaller services, each responsible for a specific business capability or function.
            These services are independently deployable and scalable.
        Independent Deployability:
            Each service can be developed, deployed, updated, and scaled independently without affecting the entire application.
        Service Boundaries:
            Services have well-defined boundaries and communicate with each other through APIs, often using lightweight protocols like REST, gRPC, or messaging systems.
        Technology Diversity:
            Different services within a microservices architecture can use different technologies, languages, databases, or frameworks, depending on their specific requirements.
        Resilience and Fault Isolation:
            Services are designed for resilience, and failures in one service don't necessarily impact the entire system.
            Isolating failures helps in maintaining overall system stability.
        Scalability:
            Microservices can be independently scaled based on the specific needs of each service, allowing efficient resource allocation.
        Continuous Deployment:
            The architecture supports continuous integration and continuous deployment (CI/CD), enabling rapid and frequent updates to individual services.
        Ease of Maintenance:
            Smaller, more focused services are typically easier to understand, maintain, and modify compared to monolithic applications.

    Monolith Architecture :
        Single Unit:
            The entire application, including its components (frontend, backend, database), is tightly integrated into a single codebase and deployed as a single unit.
        Tightly Coupled:
            Components within the application are closely interconnected, often sharing the same codebase, libraries, and resources.
        Technology Stack:
            A monolithic application generally uses a single technology stack, including a specific programming language, framework, and database system.
        Scalability:
            Scaling a monolithic application involves scaling the entire application rather than scaling specific components independently.
        Development and Deployment:
            Development, testing, and deployment are often centralized and managed as a single application lifecycle.


Two ways to render your UI?
    1st Approach :
        -   Page Load => Make an Api Call => Render the UI
    
    2nd Appoach :
        -   Page Loads => Render the UI => Make an API call => Re-render UI with data
        -   This appoach gives better UX and it is the best practice.


Shimmer UI :
    -   It is kind of using dummy/blank/fake UI untill the data has been loaded.
    -   It gives better UX.
    -   Instead of using Loading icon , we can use Shimmer UI to show untill the data is rendered.


Routing :
    -   We can install react router dom to handle our routing in react.
        eg. npm install react-router-dom   , it will add the react-router-dom in package.json
    -   createBrowserRouter is used to add all the routes path and it takes a list of array as routes.
    -   it is provided by react-router-dom and can be used by importing it.
        eg. import {createBrowserRouter} from "react-router-dom";
    -   How to define the path inside createBrowserRouter:
            -   eg.
                const router= createBrowserRouter([
                    {
                        path:"/",
                        element:<AppLayout />,
                        errorElement:<Error />
                    },
                    {
                        path:"/about",
                        element:<About />
                    },
                    {
                        path:"/contact",
                        element:<Contact />,
                    }
                ]);

    -   path is used to provide the route url.
    -   element is used to render the component on that path.
    -   errorElement is used to render the error component if any path is wrong.
    
    -   how to render this routes:
            -   ReactProvider is used to render this routes in our root.
            -   it can be imported by react-router-dom along with createBrowserRouter.
                eg. import {createBrowserRouter,RouterProvider} from "react-router-dom";
            -   Used as. root.render(<RouterProvider router={routes} />); instead of root.render(<ApplAyout />);


    -   Children Routes:
        -   The main concept of children out is to keep our header and footer intact and render the body based on the routes.
        -   Children routes can be created with children element inside createBrowserRouter.
                eg. children:[
                {
                    path:"/",
                    element:<Body />
                },
                {
                    path:"/about",
                    element:<About />
                },
                {
                    path:"/contact",
                    element:<Contact />,
                }
            ],

        -   Now we can Outlet component to render body of any routes.
        -   import {<Outlet />} from "react-router-dom";
            eg.     const AppLayout =()=>{
                    return (
                        <div className="app">
                        <Header />
                        <Outlet />
                    </div>
                    )
                    };

    
    -   Never use an anchor tag for routing any another component. As it will reload the whole page.
        Instead use link component which can be imported from react-router-dom. It only refreshes the component.
        Epitome of single page application.
        eg. import {Link} from "react-router-dom";
            <li><Link to="/contact">Contact Us</Link></li>

    -   Client Side Routing :
        -   This is client side routing.
        -   All the components have been loaded at the first time.
        -   In order to route to different pages, like about us, we are not making any network calls. We are only loading the components.

    -   Server Side Routing :
        -   When we make a call to the server and then we fetch that page and we show it in the UI.
        -   eg. if we have multiple html pages and we make a call to that routes to load that page.



    Dynamic Routing :
    -   where you pass the routes with some id or other parameter i.e. not fixed.
    -   eg. path: /restaurants/:resId   , 
    -   we use colon(:) to pass dynamic data to our routes. eg. resId is dynamic.



    
    





    